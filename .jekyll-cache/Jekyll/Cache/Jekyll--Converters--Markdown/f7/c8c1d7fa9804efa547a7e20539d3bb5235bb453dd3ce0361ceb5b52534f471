I""<p><em>这篇文章希望能够通俗地讲清楚Y组合子，如果对lambda演算感兴趣的同学可以看看最后的相关资料</em></p>

<p>在lambda中，如果我们想要递归，以斐波那契数列为例，可以这样：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">let</span> <span class="nv">power</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">n</span><span class="o">.</span> <span class="nv">IF_Else</span> <span class="nv">n==0</span> <span class="mi">1</span> <span class="nv">n*power</span><span class="p">(</span><span class="nf">n-1</span><span class="p">)</span></code></pre></figure>

<p>然而，在“纯”lambda演算中，是没有let关键字的，但我们可以暂时忘记这件事。我们需要换个方法进行递归，如果直接的递归不可行，那么我们可以尝试间接的。很容易能想到通过参数把自己传给自己：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">let</span> <span class="nv">P</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">self</span> <span class="nv">n</span><span class="o">.</span> <span class="nv">If_Else</span> <span class="nv">n==0</span> <span class="mi">1</span> <span class="nv">n*self</span><span class="p">(</span><span class="nf">self,</span> <span class="nv">n-1</span><span class="p">)</span>
<span class="nv">P</span><span class="p">(</span><span class="nf">P,</span> <span class="mi">3</span><span class="p">)</span></code></pre></figure>

<p>如果每次递归都要这么写，就显得很不优雅。我们要想一个办法，能够通用的把自己传给自己。就像上面一样。我们试着构造一下，把斐波那契数列的逻辑替换为任意函数：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">let</span> <span class="nv">gen</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">self</span><span class="o">.</span> <span class="nv">AnyFunction</span><span class="p">(</span><span class="nf">self</span><span class="p">(</span><span class="nf">self</span><span class="p">))</span>
<span class="nv">gen</span><span class="p">(</span><span class="nf">gen</span><span class="p">)</span></code></pre></figure>

<p>尝试写出斐波那契数列的AnyFunction实现：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">let</span> <span class="nv">AnyFunction</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">self</span> <span class="nv">n</span><span class="o">.</span> <span class="nv">If_Else</span> <span class="nv">n==0</span> <span class="mi">1</span> <span class="nv">n*self</span><span class="p">(</span><span class="nf">n-1</span><span class="p">)</span></code></pre></figure>

<p>经过展开之后，发现任何函数只要在AnyFunction那个位置，经过上面的代码之后，都能够实现递归。</p>

<p>其中gen(gen)展开如下：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">gen</span><span class="p">(</span><span class="nf">gen</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="nv">AnyFunction</span><span class="p">(</span><span class="nf">gen</span><span class="p">(</span><span class="nf">gen</span><span class="p">))</span></code></pre></figure>

<p>可能你会疑问，gen(gen)为什么能够表达自己呢？因为gen(gen)展开为AnyFunction(gen(gen))，它能够返回AnyFunction自身，这就得到自己了。并且这时会把这个gen(gen)再传给AnyFunction。而gen(gen)不求值时是不展开的，因此gen(gen)没有被调用时，没有任何作用，但是一旦AnyFunction内部调用了传进来的gen(gen)，那么就进行求值再次得到“自己”。通俗来讲，<strong><em>与其说gen(gen)是自身，还不如说这是一个把能够得到自己，并且把gen(gen)再次传入的函数。</em></strong></p>

<p>在理解这个机制之后，通用的递归函数已经到手。封装一下就轻而易举了，这就是传说中的Y组合子：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">let</span> <span class="nv">Y</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">f</span><span class="o">.</span> 
	<span class="nv">let</span> <span class="nv">gen</span> <span class="nv">=</span> <span class="nv">lambda</span> <span class="nv">self</span><span class="o">.</span> <span class="nv">f</span><span class="p">(</span><span class="nf">self</span><span class="p">(</span><span class="nf">self</span><span class="p">))</span>
	<span class="nv">gen</span><span class="p">(</span><span class="nf">gen</span><span class="p">)</span></code></pre></figure>

<p>再把let去掉可得到Y的定义：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">lambda</span> <span class="nv">f</span><span class="o">.</span> <span class="p">(</span><span class="k">lambda</span> <span class="nv">x</span><span class="o">.</span> <span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">lambda</span> <span class="nv">x</span><span class="o">.</span> <span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span></code></pre></figure>

<p>接下来可以试着使用一下：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span> <span class="p">(</span> <span class="nv">lambda</span> <span class="nv">f</span><span class="o">.</span> <span class="p">(</span><span class="k">lambda</span> <span class="nv">x</span><span class="o">.</span> <span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">lambda</span> <span class="nv">x</span><span class="o">.</span> <span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="nf">x</span> <span class="nv">x</span><span class="p">)))</span> <span class="p">)</span>
  <span class="p">(</span> <span class="nv">lambda</span> <span class="nv">f</span><span class="o">.</span> <span class="nv">lambda</span> <span class="nv">n</span><span class="o">.</span> <span class="nv">n==0</span> <span class="nv">?</span> <span class="mi">1</span> <span class="nv">:</span> <span class="nv">n*</span><span class="p">(</span><span class="nf">f</span> <span class="nv">n-1</span><span class="p">)</span> <span class="p">)</span>
<span class="p">)</span> <span class="mi">4</span></code></pre></figure>

<p>看，完美！证明了lambda只需要alpha/beta/eta三条规则而不需要命名。</p>

<hr />

<h3 id="相关资料从易到难排序">相关资料，从易到难排序</h3>

<ul>
  <li><a href="http://blog.csdn.net/g9yuayon/">g9的lambda calculus系列</a> <code class="language-plaintext highlighter-rouge">有很多lambda的入门讲解，幽默风趣</code></li>
  <li><a href="http://book.douban.com/subject/1632977/">The Little Schemer</a> <code class="language-plaintext highlighter-rouge">手把手学lambda</code></li>
  <li><a href="http://book.douban.com/subject/1726083/">The Seasoned Schemer</a> <code class="language-plaintext highlighter-rouge">手把手2</code></li>
  <li><a href="http://book.douban.com/subject/1451622/">SICP</a> <code class="language-plaintext highlighter-rouge">不用多说，看书评</code></li>
  <li><a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/">MIT讲SICP</a> <code class="language-plaintext highlighter-rouge">MIT的课，值得一看</code></li>
</ul>

<h3 id="其他相关资料">其他相关资料</h3>

<ul>
  <li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/">康托尔、哥德尔、图灵——永恒的金色对角线</a> <code class="language-plaintext highlighter-rouge">讲了图灵机的起源--对角线法</code></li>
  <li><a href="http://www.matrix67.com/blog/archives/4812">对角线方法之后的故事</a> <code class="language-plaintext highlighter-rouge">关于对角线法的误用</code></li>
  <li><a href="http://book.douban.com/subject/26148763/">计算的本质</a> <code class="language-plaintext highlighter-rouge">手把手用Ruby讲图灵机，比较有趣，通俗易懂</code></li>
  <li><a href="http://book.douban.com/subject/10779604/">图灵的秘密</a> <code class="language-plaintext highlighter-rouge">通俗易懂，引用图灵论文，有理有据。图灵机纸条部分比较枯燥</code></li>
</ul>
:ET